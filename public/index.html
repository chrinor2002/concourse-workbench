<!DOCTYPE html>
<html>
	<head>
		<title>Concourse NATS</title>

		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>

		<link href="/c/public/main.css" media="all" rel="stylesheet" type="text/css">
		<link href="/css/clearfix.css" media="all" rel="stylesheet" type="text/css">
		<link id="favicon" rel="icon" type="image/png" href="/c/public/images/favicon.png" />

		<style>
			.content-frame {
				padding-top: 1.5em;
			}
			.pipe-wrapper {
				line-height: 1.5em;
				float: left;
				margin: 1.5em;
				width: 150px;
				height: 9em; /* 1.5 * 4 + 1.5 + 1.5 */
			}
			.pipe {
				display: block;
				position: relative;
				width: 100%;
				height: auto;
				max-height: 9em; /* 1.5 * 4 + 1.5 + 1.5 */
			}
			.pipe .js-animation-wrapper {
				height: 100%;
				width: 100%;
				position: absolute;
				top: 0;
				left: 0;
			}
			.pipe .animation-medium {
				height: 100%;
				width: 100%;
			}
			.pipe.paused {
				opacity: 0.5;
			}
			.pipe .job {
				height: 5px;
				margin-bottom: 1px;
				width: 100%;
			}
			.pipe .text {
				padding: 1.5em;
			}
		</style>
	</head>
	<body ng-app="concourseNATS" ng-controller="concourseNATS">
		<div class="content-frame">
			<div class="pipes clearfix">
				<div ng-repeat="pipe in pipelines | filter: {paused: false} | orderBy:['name']" class="pipe-wrapper">
					<a my-pipeline href="/r/{{ pipe.url }}" class="pipe" ng-class="getPipeClasses(pipe)"></a>
				</div>
			</div>
			<div class="pipes clearfix">
				<div ng-repeat="pipe in pipelines | filter: {paused: true} | orderBy:['name']" class="pipe-wrapper">
					<a my-pipeline href="/r/{{ pipe.url }}" class="pipe" ng-class="getPipeClasses(pipe)"></a>
				</div>
			</div>
		</div>
	<script>

    var app = angular.module('concourseNATS', []);
	app.run(function($rootScope) {
		$rootScope.keys = Object.keys;
	});
	app.directive('myPipeline', function() {
	  return {
		templateUrl: 'myPipeline.html'
	  };
	});
    app.controller('concourseNATS', function($scope, $window, $http) {
		$scope.getPipeClasses = function(pipe) {
			return {
				pipe: true,
				'job-animation-node': true,
				'no-builds': pipe && pipe.aggregateStatus == 'no-builds',
				succeeded: pipe && pipe.aggregateStatus == 'succeeded',
				failed: pipe && pipe.aggregateStatus == 'failed',
				errored: pipe && pipe.aggregateStatus == 'errored',
				pending: pipe && pipe.pending == 'pending',
				started: pipe && pipe.pending == 'started',
				paused: pipe && pipe.paused
			};
		}

		$scope.getPipes = function() {
			$http({
				method: 'GET',
				url: '/c/api/v1/teams/main/pipelines'
			}).then(function(response) {
				$scope.setPipes(response.data);
			}, function(err) {
				console.error(err);
			});
		}

		// get and set the env
		$scope.getJSEnv = function() {
			$http({
				method: 'GET',
				url: '/e'
			}).then(function(response) {
				$scope.setJSEnv(response.data);
			}, function(err) {
				console.error(err);
			});
		}
		$scope.setJSEnv = function(jsenv) {
			$scope.jsenv = jsenv;
		}

		$scope.setPipes = function(pipes) {
			pipes.forEach(function(pipe, index) {
				pipes[index].aggregateStatus = 'no-builds';
			});

			var list = [];
			pipes.forEach(function(pipe, index) {
				if (!pipe.paused) {
					var promise = $http({
						method: 'GET',
						url: '/c/api/v1' + pipe.url + '/jobs'
					}).then(function(jobsResponse) {
						pipe.jobs = jobsResponse.data;
						var status = null;
						var pending = null;
						jobsResponse.data.forEach(function(job) {
							if (job.finished_build) {
								if (status === null) {
									status = job.finished_build.status;
								} else if(status === 'succeeded' && job.finished_build.status === 'failed') {
									status = job.finished_build.status;
								} else if(job.finished_build.status === 'errored') {
									status = job.finished_build.status;
								}
							}

							if (pending === null && job.next_build !== null) {
								pending = job.next_build.status;
							}
						});

						if (status !== null) {
							pipe.aggregateStatus = status;
						} else {
							pipe.aggregateStatus = 'no-builds';
						}
						pipe.pending = pending;

						return pipe;
					}, function(err) {
						console.error(err);
					});
					list.push(promise);
				} else {
					list.push(Promise.resolve(pipe));
				}
			});
			if ($scope.pipelines === null || $scope.pipelines === undefined) {
				$scope.pipelines = pipes;
			}
			Promise.all(list).then((pipes) => {
				$scope.pipelines = pipes;
			});
		}

		$scope.getPipes();
		$scope.getJSEnv();

		// setup auto refresh
		var refreshInterval;
		$scope.$watch('jsenv', function(newValue, oldValue) {
			var existingInteval = refreshInterval !== null && refreshInterval !== undefined;
			if (newValue && newValue.JS_INTERVAL > 0 && !existingInteval) {
				refreshInterval = setInterval($scope.getPipes, newValue.JS_INTERVAL);
			} else if (newValue && newValue.JS_INTERVAL > 0 && existingInteval) {
				clearInterval(existingInteval);
				refreshInterval = setInterval($scope.getPipes, newValue.JS_INTERVAL);
			} else if (existingInteval) {
				clearInterval(existingInteval);
				delete refreshInterval;
			}
		});
    });
    </script>
	</body>
</html>