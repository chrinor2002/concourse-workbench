<!DOCTYPE html>
<html>
	<head>
		<title>Concourse Workbench</title>

		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-cookies.min.js"></script>

		<link href="/c/public/main.css" media="all" rel="stylesheet" type="text/css">
		<link href="/css/clearfix.css" media="all" rel="stylesheet" type="text/css">
		<link href="/css/workbench.css" media="all" rel="stylesheet" type="text/css">
		<link id="favicon" rel="icon" type="image/png" href="/c/public/images/favicon.png" />
	</head>
	<body ng-app="concourseNATS" ng-controller="concourseNATS">
		<div class="content-frame">
			<div id="top-bar-app">
				<nav class="top-bar test">
					<ul class="groups">
						<li class="main">
							<span class="sidebar-toggle test btn-hamburger" aria-label="Toggle Filter" ng-click="sidebarToggle()">
								<i class="fa fa-filter"></i>
							</span>
						</li>
					</ul>
				</nav>
			</div>
			<div id="status-graph-top-bar">
				<span class="btn-hamburger"><i class="fa fa-heartbeat"></i></span>
				<div class="status-bar">
					<table>
						<tr>
							<td ng-repeat="pipe in pipelines | pipeFilters: getPipeFilter() | orderByPipeStatus" ng-class="getPipeStatusClasses(pipe)" title="{{getPipeStatus(pipe)}}"></td>
						</tr>
					</table>
				</div>
				<span class="btn-hamburger"><i class="fa fa-heartbeat"></i></span>
			</div>
			<div class="bottom">
				<div class="sidebar test" ng-class="{ sidebar: true, test: true, visible: sidebarVisible }">
					<ul class="team">
						<li>
							<div class="team-header">sort</div>
						</li>
						<li class="filters">
							<div class="filter">
								<label for="sortBy">Sort:</label>
								<select id="sortBy" type="text" ng-model="pipeSortBy" ng-init="pipeSortBy = 'name'">
									<option value="">None</option>
									<option value="name">Name</option>
									<option value="aggregateStatus">Status</option>
								</select>
							</div>
						</li>
						<li>
							<div class="team-header">filters</div>
						</li>
						<li class="filters">
							<div class="filter">
								<label for="filterTeamName">Team:</label>
								<input id="filterTeamName" type="text" ng-model="filter.team_name" size="13">
							</div>
							<div class="filter">
								<label for="filterName">Name:</label>
								<span ng-class="{ filterName: true, regex: filter.custom.nameRegex }">
									<input id="filterName" type="text" ng-model="filter.name" size="13">
								</span>
								<input ng-hide="!filter.custom.nameRegex" type="text" ng-model="filter.custom.nameRegexFlags" size="2">
								<input id="filterNameRegex" type="checkbox" ng-model="filter.custom.nameRegex">
								<label for="filterNameRegex">Regex</label>
							</div>
							<div class="filter">
								<label for="filterPaused">Paused:</label>
								<input id="filterPaused" type="checkbox" ng-model="filter.paused">
							</div>
							<div class="filter">
								<label for="filterPublic">Public:</label>
								<input id="filterPublic" type="checkbox" ng-model="filter.public">
							</div>
							<div class="filter">
								<label>Job Status:</label><br/>

								<input id="filterAggregateStatusAny" type="radio" ng-model="filter.aggregateStatus" value="">
								<label for="filterAggregateStatusAny">Any</label><br/>
								<input id="filterAggregateStatusFailed" type="radio" ng-model="filter.aggregateStatus" value="failed">
								<label for="filterAggregateStatusFailed">Failed</label><br/>
								<input id="filterAggregateStatusErrored" type="radio" ng-model="filter.aggregateStatus" value="errored">
								<label for="filterAggregateStatusErrored">Errored</label><br/>
								<input id="filterAggregateStatusAborted" type="radio" ng-model="filter.aggregateStatus" value="aborted">
								<label for="filterAggregateStatusAborted">Aborted</label><br/>
								<input id="filterAggregateStatusSucceeded" type="radio" ng-model="filter.aggregateStatus" value="succeeded">
								<label for="filterAggregateStatusSucceeded">Succeeded</label><br/>
								<input id="filterAggregateStatusNoBuilds" type="radio" ng-model="filter.aggregateStatus" value="no-builds">
								<label for="filterAggregateStatusNoBuilds">No-Builds</label><br/>
								<input id="filterAggregateStatusPending" type="radio" ng-model="filter.aggregateStatus" value="pending">
								<label for="filterAggregateStatusPending">Pending</label><br/>
								<input id="filterAggregateStatusStarted" type="radio" ng-model="filter.aggregateStatus" value="started">
								<label for="filterAggregateStatusStarted">Started</label><br/>
							</div>
						</li>
						<li class="reset">
							<div class="filter team-header">
								<span ng-click="resetFilter()" class="btn-reset" title="Reset">
									<i class="fa fa-undo"></i> Reset
								</span>
							</div>
						</li>
					</ul>
				</div>
				<div id="content">
					<div class="pipes clearfix">
						<div ng-repeat="pipe in pipelines | pipeFilters: getPipeFilter() | orderBy:['paused', pipeSortBy]" class="pipe-wrapper">
							<div my-pipeline class="pipe job-animation-node"></div>
						</div>
					</div>
				</div>
			</div>
		</div>
	<script>

    var app = angular.module('concourseNATS', ['ngCookies']);
	app.run(function($rootScope) {
		$rootScope.keys = Object.keys;
	});
	app.directive('myPipeline', function() {
		return {
			templateUrl: '/myPipeline.html'
		};
	});
	app.filter('orderByPipeStatus', function () {

		function pipeStatusNumber(pipe) {
			if (pipe.paused) {
				return 100;
			}
			var status = {
				'succeeded': 1,
				'failed': 2,
				'errored': 3,
				'aborted': 8,
				'no-builds': 9
			};
			return status[pipe.aggregateStatus];
		}

		return function (items, field) {
			var filtered = [];
			angular.forEach(items, function(item) {
				filtered.push(item);
			});
			filtered.sort(function (a, b) {    
				return (pipeStatusNumber(a) > pipeStatusNumber(b) ? 1 : -1);
			});
			return filtered;
		};
	});

	app.filter('pipeFilters', function ($filter) {
		return function(items, filterz) {
			if (!items) {
				return;
			}
			// ensure we have a copy of the filter, rather than the original
			var filter = angular.copy(filterz);
			filter.custom = filter.custom || {};

			// rip off the custom stuff, and prepare the filters
			var custom = angular.copy(filter.custom);
			delete filter.custom;
			if (custom.nameRegex) {
				delete filter.name;
			}

			// run the normal filter
			var result = $filter('filter').apply(this, [items, filter]);

			// are there still things we can filter?
			if (result && result.length > 0) {
				// run custom filters
				result = result.filter(function(pipe) {
					var regex = new RegExp(filterz.name, custom.regexNameFlags);
					return regex.test(pipe.name);
				});
			}

			return result;
		};
	});

    app.controller('concourseNATS', function($scope, $window, $http, $cookies, $timeout) {

		$scope.sidebarToggle = function() {
			$scope.sidebarVisible = !!!$scope.sidebarVisible;
		}

		$scope.getPipeStatus = function(pipe) {
			return pipe.paused ? 'paused' : pipe.aggregateStatus
		}

		$scope.getPipeClasses = function(pipe) {
			var classes = $scope.getPipeStatusClasses(pipe);
			return angular.extend(classes, {
				//pipe: true,
				//'job-animation-node': true
			});
		}

		$scope.getPipeStatusClasses = function(pipe) {
			return {
				'no-builds': pipe && pipe.aggregateStatus == 'no-builds',
				succeeded: pipe && pipe.aggregateStatus == 'succeeded',
				failed: pipe && pipe.aggregateStatus == 'failed',
				errored: pipe && pipe.aggregateStatus == 'errored',
				aborted: pipe && pipe.aggregateStatus == 'aborted',
				pending: pipe && pipe.pending == 'pending',
				started: pipe && pipe.pending == 'started',
				paused: pipe && pipe.paused
			};
		}

		$scope.getJobClasses = function(job) {
			var classes = $scope.getJobStatusClasses(job);
			return angular.extend(classes, {
				job: true
			});
		}

		$scope.getJobTextClasses = function(job) {
			var classes = $scope.getJobStatusClasses(job);
			return angular.extend(classes, {
				text: true
			});
		}

		$scope.getJobStatusClasses = function(job) {
			return {
				'no-builds': job && job.status == 'no-builds',
				succeeded: job && job.status == 'succeeded',
				failed: job && job.status == 'failed',
				errored: job && job.status == 'errored',
				aborted: job && job.status == 'aborted',
				pending: job && job.pending == 'pending',
				started: job && job.pending == 'started'
			};
		}

		var defaultPipeSortBy = 'name';
		var pipeSortBy = $cookies.getObject('pipeSortBy');
		if (!pipeSortBy) {
			pipeSortBy = defaultPipeSortBy;
		}
		$scope.pipeSortBy = pipeSortBy;
		$scope.$watch('pipeSortBy', function(newValue, oldValue){
			// save the value to a cookie
			$cookies.putObject('pipeSortBy', newValue);
		}, true);

		var defaultFilter = {
			public: true,
			custom: {
				nameRegexFlags: 'i'
			}
		};
		var filter = $cookies.getObject('filter');
		if (!filter) {
			filter = angular.copy(defaultFilter);
		}
		$scope.filter = filter;

		$scope.resetFilter = function() {
			$scope.filter = angular.copy(defaultFilter);
			$scope.pipeSortBy = defaultPipeSortBy;
		}

		$scope.$watch('filter', function(newValue, oldValue){
			// save the value to a cookie
			$cookies.putObject('filter', newValue);
		}, true);
		$scope.getPipeFilter = function() {
			var filters = angular.extend({}, $scope.filter);
			delete filters.nameRegex;
			if (filters.aggregateStatus === 'pending' || filters.aggregateStatus === 'started') {
				delete filters.aggregateStatus;
				filters.pending = $scope.filter.aggregateStatus;
			}

			return filters;
		}

		$scope.isFilterDisabled = function(filter) {
			var status = $scope.getPipeFilter().aggregateStatus;
			return status && status != filter;
		}

		// get and set the env
		$scope.getJSEnv = function() {
			$http({
				method: 'GET',
				url: '/e'
			}).then(function(response) {
				$scope.setJSEnv(response.data);
			}, function(err) {
				console.error(err);
			});
		}
		$scope.setJSEnv = function(jsenv) {
			$scope.jsenv = jsenv;
		}

		var pathSearch = $window.location.pathname.split('/').slice(1);
		pathSearch = pathSearch[0] === 'search' ? pathSearch.slice(1).join('/') : false;
		$scope.getPipes = function() {
			$http({
				method: 'GET',
				url: '/c/api/v1/teams/main/pipelines'
			}).then(function(response) {
				if (pathSearch) {
					response.data = response.data.filter(function(item) {
						return item.name.includes(pathSearch);
					});
				}
				$scope.setPipes(response.data);
			}, function(err) {
				console.error(err);
			});
		}

		$scope.setPipes = function(pipes) {
			pipes.forEach(function(pipe, index) {
				pipes[index].aggregateStatus = 'no-builds';
			});
			if ($scope.pipelines === null || $scope.pipelines === undefined) {
				$scope.pipelines = pipes;
			}

			$timeout(function() {
				var list = [];
				pipes.forEach(function(pipe, index) {
					if (!pipe.paused) {
						var promise = $http({
							method: 'GET',
							url: '/c/api/v1' + pipe.url + '/jobs'
						}).then(function(jobsResponse) {
							pipe.jobs = jobsResponse.data;

							// filter job names with regex
							var jobPattern = $scope.jsenv.JS_JOB_NAME_REGEX || false;
							if (jobPattern) {
								var flags = $scope.jsenv.JS_JOB_NAME_REGEX_FLAGS;
								var regex = new RegExp(jobPattern, flags);
								// filter the jobs based on the pattern regex
								pipe.jobs = pipe.jobs.filter(function(job) {
									return regex.test(job.name);
								});
							}

							// setup an aggregate status
							var status = null;
							var pending = null;
							pipe.jobs.forEach(function(job) {
								job.status = 'no-builds';
								if (job.finished_build) {
									job.status = job.finished_build.status;
									if (status === null) {
										status = job.finished_build.status;
									} else if(status === 'succeeded' && job.finished_build.status === 'failed') {
										status = job.finished_build.status;
									} else if(job.finished_build.status === 'errored') {
										status = job.finished_build.status;
									} else if(job.finished_build.status === 'aborted') {
										status = job.finished_build.status;
									}
								}

								if (pending === null && job.next_build !== null) {
									pending = job.next_build.status;
									job.pending = job.next_build.status;
								}
							});

							if (status !== null) {
								pipe.aggregateStatus = status;
							} else {
								pipe.aggregateStatus = 'no-builds';
							}
							pipe.pending = pending;

							return pipe;
						}, function(err) {
							console.error(err);
						});
						list.push(promise);
					} else {
						list.push(Promise.resolve(pipe));
					}
				});
				Promise.all(list).then((pipes) => {
					$scope.pipelines = pipes;
				});
			});
		}

		$scope.getPipes();
		$scope.getJSEnv();

		// setup auto refresh
		var refreshInterval;
		$scope.$watch('jsenv', function(newValue, oldValue) {
			var existingInteval = refreshInterval !== null && refreshInterval !== undefined;
			if (newValue && newValue.JS_INTERVAL > 0 && !existingInteval) {
				refreshInterval = setInterval($scope.getPipes, newValue.JS_INTERVAL);
			} else if (newValue && newValue.JS_INTERVAL > 0 && existingInteval) {
				clearInterval(existingInteval);
				refreshInterval = setInterval($scope.getPipes, newValue.JS_INTERVAL);
			} else if (existingInteval) {
				clearInterval(existingInteval);
				delete refreshInterval;
			}
		});
    });
    </script>
	</body>
</html>